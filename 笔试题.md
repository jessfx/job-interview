# 笔试题

jess

---

- ## jdk1.7 和 jdk1.8区别

### 1. Lambda表达式

允许把函数作为参数传递给某个方法，或者把代码当作数据来处理。

最简单的Lambda表达式可由逗号分隔的参数列表、->符号和语句块组成，例如：

    Arrays.asList( "a", "b", "d" ).forEach( e -> System.out.println( e ) );

在上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：

    Arrays.asList( "a", "b", "d" ).forEach( ( String e ) -> System.out.println( e ) );

如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如：

    Arrays.asList( "a", "b", "d" ).forEach( e -> {
        System.out.print( e );
        System.out.print( e );
    } );

Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同：

    String separator = ",";
    Arrays.asList( "a", "b", "d" ).forEach( 
        ( String e ) -> System.out.print( e + separator ) );

    final String separator = ",";
    Arrays.asList( "a", "b", "d" ).forEach( 
        ( String e ) -> System.out.print( e + separator ) );

Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同：

    Arrays.asList( "a", "b", "d" ).sort( ( e1, e2 ) -> e1.compareTo( e2 ) );

    Arrays.asList( "a", "b", "d" ).sort( ( e1, e2 ) -> {
        int result = e1.compareTo( e2 );
        return result;
    } );

解决方法是使用函数接口。函数接口是只包含一个抽象方法声明的接口。

@FunctionInterface用于显式说明该接口是函数接口

    @FunctionalInterface
    public interface Functional {
        void method();
    }

默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。

    @FunctionalInterface
    public interface FunctionalDefaultMethods {
        void method();

        default void defaultMethod() {
        }
    }

### 2. 接口的默认方法和静态方法

java8现在可以定义接口的默认方法和静态方法

    private interface Defaulable {
        // Interfaces now allow default methods, the implementer may or
        // may not implement (override) them.
        default String notRequired() {
            return "Default implementation";
        }
    }

    public static DefaultImpl implements Defaultable{
    }

    public static OverrideImple implements Defaultable{
        @Override
        default String a(){
            return "override Defaultable default method"
        }
    }

    private interface DefaulableFactory {
        // Interfaces now allow static methods
        static Defaulable create( Supplier< Defaulable > supplier ) {
            return supplier.get();
        }
    }

    public static void main( String[] args ) {
        Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new );
        System.out.println( defaulable.notRequired() );
        defaulable = DefaulableFactory.create( OverridableImpl::new );
        System.out.println( defaulable.notRequired() );
    }

### 3. 方法引用

方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。

例子中，Car类是不同方法引用的例子，可以帮助读者区分四种类型的方法引用。

    public static class Car {
        public static Car create( final Supplier< Car > supplier ) {
            return supplier.get();
        }

        public static void collide( final Car car ) {
            System.out.println( "Collided " + car.toString() );
        }

        public void follow( final Car another ) {
            System.out.println( "Following the " + another.toString() );
        }

        public void repair() {
            System.out.println( "Repaired " + this.toString() );
        }
    }

第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：`Class<T>::new`。注意：这个构造器没有参数。

    final Car car = Car.create( Car::new );
    final List< Car > cars = Arrays.asList( car );

第二种方法引用的类型是静态方法引用，语法是`Class::static_method`。注意：这个方法接受一个Car类型的参数。

    cars.forEach( Car::collide );

第三种方法引用的类型是某个类的成员方法的引用，语法是`Class::method`，注意，这个方法没有定义入参：

    cars.forEach( Car::repair );

第四种方法引用的类型是某个实例对象的成员方法的引用，语法是`instance::method`。注意：这个方法接受一个Car类型的参数：

    final Car police = Car.create( Car::new );
    cars.forEach( police::follow );

### 4. 重复注解

### 5. 更好的类型推断

### 6. 拓宽注解的应用场景

Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。

- ## springboot

- ## 回溯算法

- ## 堆栈

- ## 排序算法

- ## 查找算法

- ## tcp/ip

- ## 多线程(生产者消费者，购票)

- ## java设计模式

### 1. 工厂模式

### 2. 适配器模式


- ## wordcount流程

- ## shuffle partition combine 过程

- ## map reduce数量设计

- ## zookeeper工作原理、选举原理：选出编号最小的作为leader，其他作为follower；集群资源集中组织成树状结构

- ## hive hql，有没有用过hive、用hive来做什么

- ## hbase 框架、工作原理、存储原理、常用shell命令

- ## linux 常用shell命令、统计文件行数、查找文件、查找文件内容、linux脚本编程

- ## java hashmap和hashtable区别

- ## 算法的鲁棒性、可扩展性

- ## mysql常用命令、顶层结构：B+树

- ## mysql和mongodb区别

- ## kmeans收敛、过程

- ## 神经网络常用激活函数，singmoid、tanh、relu

- ## 梯度下降法

- ## 准确率、召回率、f1值
